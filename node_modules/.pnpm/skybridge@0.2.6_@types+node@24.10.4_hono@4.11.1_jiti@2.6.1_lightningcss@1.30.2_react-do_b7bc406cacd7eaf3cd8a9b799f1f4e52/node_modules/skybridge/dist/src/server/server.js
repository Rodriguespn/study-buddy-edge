import { McpServer as McpServerBase, } from "@modelcontextprotocol/sdk/server/mcp.js";
import { templateHelper } from "./templateHelper.js";
import { readFileSync } from "node:fs";
import path from "node:path";
export class McpServer extends McpServerBase {
    widget(name, resourceConfig, toolConfig, toolCallback) {
        const uri = `ui://widgets/${name}.html`;
        const resourceMetadata = { ...(resourceConfig._meta ?? {}) };
        if (toolConfig.description !== undefined) {
            resourceMetadata["openai/widgetDescription"] = toolConfig.description;
        }
        this.resource(name, uri, {
            ...resourceConfig,
            _meta: resourceMetadata,
        }, async (_uri, extra) => {
            const serverUrl = process.env.NODE_ENV === "production"
                ? `https://${extra?.requestInfo?.headers?.["x-forwarded-host"] ??
                    extra?.requestInfo?.headers?.host}`
                : `http://localhost:3000`;
            const html = process.env.NODE_ENV === "production"
                ? templateHelper.renderProduction({
                    serverUrl,
                    widgetFile: this.lookupDistFile(`src/widgets/${name}.tsx`),
                    styleFile: this.lookupDistFile("style.css"),
                })
                : templateHelper.renderDevelopment({
                    serverUrl,
                    widgetName: name,
                });
            return {
                contents: [
                    {
                        uri,
                        mimeType: "text/html+skybridge",
                        text: html,
                    },
                ],
            };
        });
        const toolMeta = {
            ...toolConfig._meta,
            "openai/outputTemplate": uri,
        };
        this.registerTool(name, {
            ...toolConfig,
            _meta: toolMeta,
        }, toolCallback);
    }
    lookupDistFile(key) {
        const manifest = JSON.parse(readFileSync(path.join(process.cwd(), "dist", "assets", ".vite", "manifest.json"), "utf-8"));
        return manifest[key]?.file;
    }
}
//# sourceMappingURL=server.js.map